# Run Meeting with LangGraph - Uses ChromaDB VectorDB Memory
def run_meeting(task: str, user_profile: str = "", turns: int = TURNS, agents: List[str] | None = None, user_id: str = "system",meeting_type: str = "chat") -> Dict:
    if agents is None:
        agents = list(PERSONAS.keys())
    
    graph = StateGraph(AgentState)
    
    recommend_nodes = []
    for persona in agents:
        agent_node = create_agent_node(persona)
        recommend_node_name = f"recommend_{persona}"
        graph.add_node(recommend_node_name, agent_node)
        recommend_nodes.append(recommend_node_name)
    
    graph.add_node("update_memory", update_memory_node)
    graph.add_node("start_recommend", lambda state: state)
    graph.add_edge(START, "start_recommend")
    
    for r_node in recommend_nodes:
        graph.add_edge("start_recommend", r_node)
    
    graph.add_node("after_recommend", lambda state: state)
    for r_node in recommend_nodes:
        graph.add_edge(r_node, "after_recommend")
    
    def increment_turn(state):
        current = state.get("current_turn", 0)
        return {"current_turn": current + 1}
    
    graph.add_node("increment", increment_turn)
    graph.add_edge("after_recommend", "increment")
    
    def decide_to_continue(state):
        current_turn = state.get("current_turn", 0)
        turns = state.get("turns", 1)
        return "continue" if current_turn < turns else "end"
    
    graph.add_conditional_edges(
        "increment",
        decide_to_continue,
        {"continue": "start_recommend", "end": "update_memory"}
    )
    
    graph.add_edge("update_memory", END)
    
    app_graph = graph.compile()
    
    # Generate run ID
    run_id = str(uuid.uuid4())
    
    initial_state = {
        "messages": [],
        "recommendations": {},
        "task": task,
        "user_profile": user_profile,
        "current_turn": 0,
        "agents": agents,
        "turns": turns,
        "run_id": run_id,
        "user_id": user_id
    }
    
    print(f"ðŸš€ Starting meeting with {len(agents)} agents, {turns} turn(s)...")
    final_state = app_graph.invoke(initial_state)
    print(f"âœ… Meeting completed! Run ID: {run_id}")
    # Save run to JSON file (for Node.js compatibility)
    os.makedirs(RUNS_DIR, exist_ok=True)
    run_path = os.path.join(RUNS_DIR, f"run_{run_id}.json")
    with open(run_path, "w") as f:
        json.dump({
            "task": task,
            "user_profile": user_profile,
            "turns": turns,
            "agents": agents,
            "recommendations": final_state["recommendations"]
        }, f, indent=2)
    
    return {"run_id": run_id, "recommendations": final_state["recommendations"]}
