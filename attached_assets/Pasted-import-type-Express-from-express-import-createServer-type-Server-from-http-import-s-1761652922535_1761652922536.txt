import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { insertUserSchema, loginSchema, insertTwinSchema, AI_AGENTS } from "@shared/schema";
import { generateAgentRecommendation, generateChatResponse } from "./gemini";
import bcrypt from "bcrypt";
import session from "express-session";
import connectPgSimple from "connect-pg-simple";
import { pool } from "./db";
import axios from "axios";
import FormData from "form-data";
import multer from "multer";
import path from "path";
import fs from "fs";

const PgSession = connectPgSimple(session);

declare module "express-session" {
  interface SessionData {
    userId: string;
  }
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Session middleware
  app.use(
    session({
      store: new PgSession({
        pool,
        createTableIfMissing: true,
      }),
      secret: process.env.SESSION_SECRET || "ai-leaders-boardroom-secret",
      resave: false,
      saveUninitialized: false,
      cookie: {
        maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
      },
    })
  );

  // Auth middleware
  const requireAuth = (req: any, res: any, next: any) => {
    if (!req.session.userId) {
      return res.status(401).json({ error: "Unauthorized" });
    }
    next();
  };

  // Build user profile string from user data
  const buildUserProfile = (user: any): string => {
    return `Name: ${user.name}
Company: ${user.companyName}
Designation: ${user.designation}
Role Description: ${user.roleDescription}
Product Expectations: ${user.productExpectations}
Company Website: ${user.companyWebsite}
Role Details: ${user.roleDetails}
1-Year Goal: ${user.goalOneYear}
5-Year Goal: ${user.goalFiveYears}`;
  };

  // AUTHROUTES
  app.post("/api/auth/signup", async (req, res) => {
    try {
      const data = insertUserSchema.parse(req.body);

      // Check if user exists
      const existingUser = await storage.getUserByEmail(data.email);
      if (existingUser) {
        return res.status(400).json({ error: "Email already registered" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(data.password, 10);

      // Create user
      const user = await storage.createUser({
        ...data,
        password: hashedPassword,
      });

      // Set session
      req.session.userId = user.id;

      res.json({
        id: user.id,
        email: user.email,
        name: user.name,
        photo: user.photo
      });
    } catch (error: any) {
      console.error("Signup error:", error);
      res.status(400).json({ error: error.message || "Signup failed" });
    }
  });

  app.post("/api/auth/login", async (req, res) => {
    try {
      const data = loginSchema.parse(req.body);

      // Find user
      const user = await storage.getUserByEmail(data.email);
      if (!user) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      // Verify password
      const validPassword = await bcrypt.compare(data.password, user.password);
      if (!validPassword) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      // Set session
      req.session.userId = user.id;

      res.json({
        id: user.id,
        email: user.email,
        name: user.name,
        photo: user.photo
      });
    } catch (error: any) {
      console.error("Login error:", error);
      res.status(400).json({ error: error.message || "Login failed" });
    }
  });

  app.post("/api/auth/logout", (req, res) => {
    req.session.destroy((err) => {
      if (err) {
        return res.status(500).json({ error: "Logout failed" });
      }
      res.json({ success: true });
    });
  });

  app.get("/api/auth/me", requireAuth, async (req, res) => {
    try {
      const user = await storage.getUser(req.session.userId!);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }

      const { password, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      res.status(500).json({ error: "Failed to get user" });
    }
  });

  // MEETING/RUN ROUTES - Forwards ALL agent operations to Python API
  app.post("/api/meeting", requireAuth, async (req, res) => {
    try {
      const { task, agents, turns = 1 } = req.body;

      if (!task || !agents || agents.length === 0) {
        return res.status(400).json({ error: "Task and agents are required" });
      }

      // Get user for profile
      const user = await storage.getUser(req.session.userId!);
      if (!user) {
        return res.status(401).json({ error: "User not found" });
      }

      const userProfile = buildUserProfile(user);

      // Forward ALL agent operations to Python API with ChromaDB memory
      const axios = await import('axios');
      const pythonResponse = await axios.default.post("http://localhost:8000/meeting", {
        task,
        user_profile: userProfile,
        turns,
        agents,
        user_id: req.session.userId!.toString(),  // Pass user ID for VectorDB tracking
        meeting_type: req.body.meeting_type || "chat",  // Forward meeting type
      });

      const { run_id: pythonRunId, recommendations } = pythonResponse.data;

      // Save run to PostgreSQL database (Node.js handles DB persistence)
      // Store pythonRunId so we can map between DB ID and Python UUID
      const run = await storage.createRun({
        userId: req.session.userId!,
        task,
        userProfile,
        turns,
        agents,
        recommendations,
      });

      console.log(`Meeting completed: DB ID ${run.id}, Python Run ID ${pythonRunId}`);

      // IMPORTANT: Return Python's run_id to frontend (not DB ID)
      // Python /chat endpoint needs Python's UUID to find the run file
      res.json({
        runId: pythonRunId,  // Use Python's UUID so /chat can find the run file
        recommendations,
      });
    } catch (error: any) {
      console.error("Meeting error:", error);
      res.status(500).json({ error: error.message || "Failed to run meeting" });
    }
  });

  // CHAT ROUTES - Now uses Python VectorDB API
  app.post("/api/chat", requireAuth, async (req, res) => {
    try {
      const { runId, agent, message } = req.body;